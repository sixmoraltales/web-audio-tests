<html>
<head>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
</head>
<body>
  <h1>Object Detection with TensorFlow.js</h1>
  <button id="start-button">Start Camera</button>
  <video id="video" width="640" height="480" autoplay muted></video>
  <div id="predictions"></div>
  <script>
    var dorianChord = [261.63, 329.63, 392, 523.25]; // C Dorian: C min6, F 9
    var phrygianChord = [261.63, 277.18, 349.23, 415.3]; // C Phrygian: C min, D♭ maj
    var lydianChord = [261.63, 329.63, 415.3, 493.88]; // C Lydian: C maj7♭5, B -7
    var mixolydianChord = [261.63, 329.63, 392, 466.16]; // C Mixolydian: C 13, E -7♭5

    // Create an array of modal chords
    var modalChords = [dorianChord, phrygianChord, lydianChord, mixolydianChord];

    // Get the video element and the start button
    const video = document.getElementById("video");
    const startButton = document.getElementById("start-button");

    // Define variables for audio context
    let audioContext;
    var convolver

    // Flags to track detection state of each object type
    let personDetected = false;
    let cellphoneDetected = false;
    let chairDetected = false;

    // Load the COCO-SSD model
    let model;
    cocoSsd.load().then(loadedModel => {
      model = loadedModel;
      console.log("Model loaded");
    });

    // Define a function to start the camera and audio context
    function startCamera() {
      // Initialize the audio context
      audioContext = new AudioContext();

      // Create a gain node for the volume
      var gainNode = audioContext.createGain();
      gainNode.gain.value = 0.1; // Set the volume to 50%

      // Connect the gain node to the destination (speakers)
      gainNode.connect(audioContext.destination);

      // Create a convolver node for the reverb effect
      convolver = audioContext.createConvolver();

      // Fetch the impulse response from the local directory
      fetch("6 Spaces 06 Scoring Stage  M-to-S.wav")
        .then(response => response.arrayBuffer())
        .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))
        .then(audioBuffer => {
          // Set the impulse response to the convolver
          convolver.buffer = audioBuffer;

          // Connect the convolver to the gain node
          convolver.connect(gainNode);
        })
        .catch(e => console.error(e));

      // Ask for permission to access the camera
      navigator.mediaDevices.getUserMedia({video: true})
        .then(stream => {
          // Set the video source to the stream
          video.srcObject = stream;
          // Start the video
          video.play();
          // Run the object detection every 100 milliseconds
          setInterval(runDetection, 100);
        })
        .catch(error => {
          // Handle the error
          console.error(error);
          alert("Please allow access to the camera");
        });
    }

    // Define a function to play a randomly chosen modal chord
    // function playRandomModalChord() {
    //   const modes = [
    //     { name: 'Ionian', intervals: [0, 4, 7] }, // Major chord
    //     { name: 'Dorian', intervals: [0, 3, 7] },
    //     { name: 'Phrygian', intervals: [0, 3, 7] },
    //     { name: 'Lydian', intervals: [0, 4, 7] },
    //     { name: 'Mixolydian', intervals: [0, 4, 7] },
    //     { name: 'Aeolian', intervals: [0, 3, 7] }, // Minor chord
    //     { name: 'Locrian', intervals: [0, 3, 6] }
    //   ];
    //   const rootFrequency = 440; // A4
    //   const mode = modes[Math.floor(Math.random() * modes.length)];
    //   const chordFrequencies = mode.intervals.map(interval => 
    //     rootFrequency * Math.pow(2, interval / 12)
    //   );

    //   // Reduce the gain for each oscillator to avoid distortion
    //   const gainValue = 1 / chordFrequencies.length;

    //   chordFrequencies.forEach(frequency => {
    //     const oscillator = audioContext.createOscillator();
    //     oscillator.type = 'sine';
    //     oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

    //     const envelope = audioContext.createGain();
    //     envelope.gain.setValueAtTime(0, audioContext.currentTime);
    //     envelope.gain.linearRampToValueAtTime(gainValue, audioContext.currentTime + 0.01); // Attack
    //     envelope.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1); // Release

    //     oscillator.connect(envelope);
    //     envelope.connect(audioContext.destination);

    //     oscillator.start();
    //     oscillator.stop(audioContext.currentTime + 1);
    //   });

    //   soundPlayed = true; // Set the flag to true after playing the sound
    // }

    function playRandomModalChord() {
      // Generate a random number between 0 and 3
      var randomIndex = Math.floor(Math.random() * 4);

      // Select a random modal chord from the array
      var modalChord = modalChords[randomIndex];

      // Loop through the frequencies of the modal chord
      for (var i = 0; i < modalChord.length; i++) {
        // Create a sine wave oscillator for each frequency
        var oscillator = audioContext.createOscillator();
        oscillator.type = "sine";
        oscillator.frequency.value = modalChord[i];

        // Create a gain node for the envelope
        var envelope = audioContext.createGain();
        envelope.gain.value = 0; // Initial volume

        // Connect the oscillator to the envelope
        oscillator.connect(envelope);

        // Connect the envelope to the convolver
        envelope.connect(convolver);

        // Start the oscillator
        oscillator.start();

        // Create a new time constant for the envelope
        var now = audioContext.currentTime;

        // Set the envelope parameters
        var attack = 0.1; // Time to reach maximum volume
        var decay = 0.2; // Time to reach sustain volume
        var sustain = 0.5; // Sustain volume level
        var release = 0.5; // Time to reach zero volume

        // Apply the envelope to the gain node
        envelope.gain.cancelScheduledValues(now); // Cancel any previous changes
        envelope.gain.setValueAtTime(0, now); // Set the initial volume to zero
        envelope.gain.linearRampToValueAtTime(1, now + attack); // Ramp up to maximum volume
        envelope.gain.linearRampToValueAtTime(sustain, now + attack + decay); // Ramp down to sustain volume
        envelope.gain.linearRampToValueAtTime(0, now + attack + decay + release); // Ramp down to zero volume

        // Stop the oscillator after the release time
        oscillator.stop(now + attack + decay + release);
      }

      // Set the flag to true
      isPlaying = true;

      // Set a timeout to reset the flag after the release time
      setTimeout(function() {
        isPlaying = false;
      }, (attack + decay + release) * 1000);
    }

    // Define a function to run the object detection
    function runDetection() {
      // Check if the model is loaded
      if (model) {
        // Detect objects in the video frame
        model.detect(video)
          .then(predictions => {
            // Reset detection flags if no objects are detected
            if (predictions.length === 0) {
              personDetected = cellphoneDetected = chairDetected = false;
            }

            predictions.forEach(prediction => {
              // Check for new detections and play sound accordingly
              if (prediction.class === 'person' && !personDetected) {
                playRandomModalChord();
                personDetected = true;
              } else if (prediction.class === 'cell phone' && !cellphoneDetected) {
                playRandomModalChord();
                cellphoneDetected = true;
              } else if (prediction.class === 'chair' && !chairDetected) {
                playRandomModalChord();
                chairDetected = true;
              }
            });

            // Display the predictions on the webpage
            displayPredictions(predictions);
          });
      }
    }

    // Define a function to display predictions
    function displayPredictions(predictions) {
      // Clear any previous predictions displayed
      const predictionsContainer = document.getElementById("predictions");
      predictionsContainer.innerHTML = '';

      // Create elements for each prediction and add to the container
      predictions.forEach(prediction => {
        const p = document.createElement("p");
        p.innerText = `Detected: ${prediction.class} with ${Math.round(prediction.score * 100)}% confidence`;
        predictionsContainer.appendChild(p);
      });
    }

    // Add a click event listener to the start button
    startButton.addEventListener("click", startCamera);
  </script>
</body>
</html>
